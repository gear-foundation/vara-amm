// Code generated by sails-client-gen. DO NOT EDIT.
#[allow(unused_imports)]
use sails_rs::{client::*, collections::*, prelude::*};
pub struct FactoryClientProgram;
impl sails_rs::client::Program for FactoryClientProgram {}
pub trait FactoryClient {
    type Env: sails_rs::client::GearEnv;
    fn factory(&self) -> sails_rs::client::Service<factory::FactoryImpl, Self::Env>;
}
impl<E: sails_rs::client::GearEnv> FactoryClient
    for sails_rs::client::Actor<FactoryClientProgram, E>
{
    type Env = E;
    fn factory(&self) -> sails_rs::client::Service<factory::FactoryImpl, Self::Env> {
        self.service(stringify!(Factory))
    }
}
pub trait FactoryClientCtors {
    type Env: sails_rs::client::GearEnv;
    #[allow(clippy::new_ret_no_self)]
    #[allow(clippy::wrong_self_convention)]
    fn new(
        self,
        pair_id: CodeId,
        admin: ActorId,
        fee_to: ActorId,
        config: Config,
        treasury_id: ActorId,
    ) -> sails_rs::client::PendingCtor<FactoryClientProgram, io::New, Self::Env>;
}
impl<E: sails_rs::client::GearEnv> FactoryClientCtors
    for sails_rs::client::Deployment<FactoryClientProgram, E>
{
    type Env = E;
    fn new(
        self,
        pair_id: CodeId,
        admin: ActorId,
        fee_to: ActorId,
        config: Config,
        treasury_id: ActorId,
    ) -> sails_rs::client::PendingCtor<FactoryClientProgram, io::New, Self::Env> {
        self.pending_ctor((pair_id, admin, fee_to, config, treasury_id))
    }
}

pub mod io {
    use super::*;
    sails_rs::io_struct_impl!(New (pair_id: CodeId, admin: ActorId, fee_to: ActorId, config: super::Config, treasury_id: ActorId) -> ());
}

pub mod factory {
    use super::*;
    pub trait Factory {
        type Env: sails_rs::client::GearEnv;
        fn add_pair(
            &mut self,
            token0: ActorId,
            token1: ActorId,
            pair_address: ActorId,
        ) -> sails_rs::client::PendingCall<io::AddPair, Self::Env>;
        fn change_fee_to(
            &mut self,
            fee_to: ActorId,
        ) -> sails_rs::client::PendingCall<io::ChangeFeeTo, Self::Env>;
        fn change_treasury_id(
            &mut self,
            new_treasury_id: ActorId,
        ) -> sails_rs::client::PendingCall<io::ChangeTreasuryId, Self::Env>;
        fn create_pair(
            &mut self,
            token0: ActorId,
            token1: ActorId,
        ) -> sails_rs::client::PendingCall<io::CreatePair, Self::Env>;
        fn fee_to(&self) -> sails_rs::client::PendingCall<io::FeeTo, Self::Env>;
        fn get_pair(
            &self,
            token0: ActorId,
            token1: ActorId,
        ) -> sails_rs::client::PendingCall<io::GetPair, Self::Env>;
        fn pairs(&self) -> sails_rs::client::PendingCall<io::Pairs, Self::Env>;
        fn treasury_id(&self) -> sails_rs::client::PendingCall<io::TreasuryId, Self::Env>;
    }
    pub struct FactoryImpl;
    impl<E: sails_rs::client::GearEnv> Factory for sails_rs::client::Service<FactoryImpl, E> {
        type Env = E;
        fn add_pair(
            &mut self,
            token0: ActorId,
            token1: ActorId,
            pair_address: ActorId,
        ) -> sails_rs::client::PendingCall<io::AddPair, Self::Env> {
            self.pending_call((token0, token1, pair_address))
        }
        fn change_fee_to(
            &mut self,
            fee_to: ActorId,
        ) -> sails_rs::client::PendingCall<io::ChangeFeeTo, Self::Env> {
            self.pending_call((fee_to,))
        }
        fn change_treasury_id(
            &mut self,
            new_treasury_id: ActorId,
        ) -> sails_rs::client::PendingCall<io::ChangeTreasuryId, Self::Env> {
            self.pending_call((new_treasury_id,))
        }
        fn create_pair(
            &mut self,
            token0: ActorId,
            token1: ActorId,
        ) -> sails_rs::client::PendingCall<io::CreatePair, Self::Env> {
            self.pending_call((token0, token1))
        }
        fn fee_to(&self) -> sails_rs::client::PendingCall<io::FeeTo, Self::Env> {
            self.pending_call(())
        }
        fn get_pair(
            &self,
            token0: ActorId,
            token1: ActorId,
        ) -> sails_rs::client::PendingCall<io::GetPair, Self::Env> {
            self.pending_call((token0, token1))
        }
        fn pairs(&self) -> sails_rs::client::PendingCall<io::Pairs, Self::Env> {
            self.pending_call(())
        }
        fn treasury_id(&self) -> sails_rs::client::PendingCall<io::TreasuryId, Self::Env> {
            self.pending_call(())
        }
    }

    pub mod io {
        use super::*;
        sails_rs::io_struct_impl!(AddPair (token0: ActorId, token1: ActorId, pair_address: ActorId) -> ());
        sails_rs::io_struct_impl!(ChangeFeeTo (fee_to: ActorId) -> ());
        sails_rs::io_struct_impl!(ChangeTreasuryId (new_treasury_id: ActorId) -> ());
        sails_rs::io_struct_impl!(CreatePair (token0: ActorId, token1: ActorId) -> ());
        sails_rs::io_struct_impl!(FeeTo () -> ActorId);
        sails_rs::io_struct_impl!(GetPair (token0: ActorId, token1: ActorId) -> ActorId);
        sails_rs::io_struct_impl!(Pairs () -> Vec<((ActorId,ActorId,),ActorId,)>);
        sails_rs::io_struct_impl!(TreasuryId () -> ActorId);
    }

    #[cfg(not(target_arch = "wasm32"))]
    pub mod events {
        use super::*;
        #[derive(PartialEq, Debug, Encode, Decode)]
        #[codec(crate = sails_rs::scale_codec)]
        pub enum FactoryEvents {
            PairCreated {
                token0: ActorId,
                token1: ActorId,
                pair_address: ActorId,
            },
        }
        impl sails_rs::client::Event for FactoryEvents {
            const EVENT_NAMES: &'static [Route] = &["PairCreated"];
        }
        impl sails_rs::client::ServiceWithEvents for FactoryImpl {
            type Event = FactoryEvents;
        }
    }
}
/// Config that will be used to send messages to the other programs or create programs.
#[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo)]
#[codec(crate = sails_rs::scale_codec)]
#[scale_info(crate = sails_rs::scale_info)]
pub struct Config {
    /// Gas limit for token operations. Token operations include:
    /// - Mint
    /// - Burn
    /// - TransferFrom
    pub gas_for_token_ops: u64,
    /// Gas to reserve for reply processing.
    pub gas_for_reply_deposit: u64,
    /// Timeout in blocks that current program will wait for reply from
    /// the other programs such as VFT
    pub reply_timeout: u32,
    pub gas_for_full_tx: u64,
    pub gas_for_pair_creation: u64,
    pub gas_to_change_fee_to: u64,
}
