// Code generated by sails-client-gen. DO NOT EDIT.
#[allow(unused_imports)]
use sails_rs::collections::BTreeMap;
#[allow(unused_imports)]
use sails_rs::{
    String,
    calls::{Activation, Call, Query, Remoting, RemotingAction},
    prelude::*,
};
pub struct FactoryClientFactory<R> {
    #[allow(dead_code)]
    remoting: R,
}
impl<R> FactoryClientFactory<R> {
    #[allow(unused)]
    pub fn new(remoting: R) -> Self {
        Self { remoting }
    }
}
impl<R: Remoting + Clone> traits::FactoryClientFactory for FactoryClientFactory<R> {
    type Args = R::Args;
    fn new(
        &self,
        pair_id: CodeId,
        admin: ActorId,
        fee_to: ActorId,
        config: Config,
        treasury_id: ActorId,
    ) -> impl Activation<Args = R::Args> {
        RemotingAction::<_, factory_client_factory::io::New>::new(
            self.remoting.clone(),
            (pair_id, admin, fee_to, config, treasury_id),
        )
    }
}

pub mod factory_client_factory {
    use super::*;
    pub mod io {
        use super::*;
        use sails_rs::calls::ActionIo;
        pub struct New(());
        impl New {
            #[allow(dead_code)]
            pub fn encode_call(
                pair_id: CodeId,
                admin: ActorId,
                fee_to: ActorId,
                config: super::Config,
                treasury_id: ActorId,
            ) -> Vec<u8> {
                <New as ActionIo>::encode_call(&(pair_id, admin, fee_to, config, treasury_id))
            }
        }
        impl ActionIo for New {
            const ROUTE: &'static [u8] = &[12, 78, 101, 119];
            type Params = (CodeId, ActorId, ActorId, super::Config, ActorId);
            type Reply = ();
        }
    }
}
pub struct Factory<R> {
    remoting: R,
}
impl<R> Factory<R> {
    pub fn new(remoting: R) -> Self {
        Self { remoting }
    }
}
impl<R: Remoting + Clone> traits::Factory for Factory<R> {
    type Args = R::Args;
    fn add_pair(
        &mut self,
        token0: ActorId,
        token1: ActorId,
        pair_address: ActorId,
    ) -> impl Call<Output = (), Args = R::Args> {
        RemotingAction::<_, factory::io::AddPair>::new(
            self.remoting.clone(),
            (token0, token1, pair_address),
        )
    }
    fn change_fee_to(&mut self, fee_to: ActorId) -> impl Call<Output = (), Args = R::Args> {
        RemotingAction::<_, factory::io::ChangeFeeTo>::new(self.remoting.clone(), fee_to)
    }
    fn change_treasury_id(
        &mut self,
        new_treasury_id: ActorId,
    ) -> impl Call<Output = (), Args = R::Args> {
        RemotingAction::<_, factory::io::ChangeTreasuryId>::new(
            self.remoting.clone(),
            new_treasury_id,
        )
    }
    fn create_pair(
        &mut self,
        token0: ActorId,
        token1: ActorId,
    ) -> impl Call<Output = (), Args = R::Args> {
        RemotingAction::<_, factory::io::CreatePair>::new(self.remoting.clone(), (token0, token1))
    }
    fn fee_to(&self) -> impl Query<Output = ActorId, Args = R::Args> {
        RemotingAction::<_, factory::io::FeeTo>::new(self.remoting.clone(), ())
    }
    fn get_pair(
        &self,
        token0: ActorId,
        token1: ActorId,
    ) -> impl Query<Output = ActorId, Args = R::Args> {
        RemotingAction::<_, factory::io::GetPair>::new(self.remoting.clone(), (token0, token1))
    }
    fn pairs(&self) -> impl Query<Output = Vec<((ActorId, ActorId), ActorId)>, Args = R::Args> {
        RemotingAction::<_, factory::io::Pairs>::new(self.remoting.clone(), ())
    }
    fn treasury_id(&self) -> impl Query<Output = ActorId, Args = R::Args> {
        RemotingAction::<_, factory::io::TreasuryId>::new(self.remoting.clone(), ())
    }
}

pub mod factory {
    use super::*;

    pub mod io {
        use super::*;
        use sails_rs::calls::ActionIo;
        pub struct AddPair(());
        impl AddPair {
            #[allow(dead_code)]
            pub fn encode_call(token0: ActorId, token1: ActorId, pair_address: ActorId) -> Vec<u8> {
                <AddPair as ActionIo>::encode_call(&(token0, token1, pair_address))
            }
        }
        impl ActionIo for AddPair {
            const ROUTE: &'static [u8] = &[
                28, 70, 97, 99, 116, 111, 114, 121, 28, 65, 100, 100, 80, 97, 105, 114,
            ];
            type Params = (ActorId, ActorId, ActorId);
            type Reply = ();
        }
        pub struct ChangeFeeTo(());
        impl ChangeFeeTo {
            #[allow(dead_code)]
            pub fn encode_call(fee_to: ActorId) -> Vec<u8> {
                <ChangeFeeTo as ActionIo>::encode_call(&fee_to)
            }
        }
        impl ActionIo for ChangeFeeTo {
            const ROUTE: &'static [u8] = &[
                28, 70, 97, 99, 116, 111, 114, 121, 44, 67, 104, 97, 110, 103, 101, 70, 101, 101,
                84, 111,
            ];
            type Params = ActorId;
            type Reply = ();
        }
        pub struct ChangeTreasuryId(());
        impl ChangeTreasuryId {
            #[allow(dead_code)]
            pub fn encode_call(new_treasury_id: ActorId) -> Vec<u8> {
                <ChangeTreasuryId as ActionIo>::encode_call(&new_treasury_id)
            }
        }
        impl ActionIo for ChangeTreasuryId {
            const ROUTE: &'static [u8] = &[
                28, 70, 97, 99, 116, 111, 114, 121, 64, 67, 104, 97, 110, 103, 101, 84, 114, 101,
                97, 115, 117, 114, 121, 73, 100,
            ];
            type Params = ActorId;
            type Reply = ();
        }
        pub struct CreatePair(());
        impl CreatePair {
            #[allow(dead_code)]
            pub fn encode_call(token0: ActorId, token1: ActorId) -> Vec<u8> {
                <CreatePair as ActionIo>::encode_call(&(token0, token1))
            }
        }
        impl ActionIo for CreatePair {
            const ROUTE: &'static [u8] = &[
                28, 70, 97, 99, 116, 111, 114, 121, 40, 67, 114, 101, 97, 116, 101, 80, 97, 105,
                114,
            ];
            type Params = (ActorId, ActorId);
            type Reply = ();
        }
        pub struct FeeTo(());
        impl FeeTo {
            #[allow(dead_code)]
            pub fn encode_call() -> Vec<u8> {
                <FeeTo as ActionIo>::encode_call(&())
            }
        }
        impl ActionIo for FeeTo {
            const ROUTE: &'static [u8] = &[
                28, 70, 97, 99, 116, 111, 114, 121, 20, 70, 101, 101, 84, 111,
            ];
            type Params = ();
            type Reply = ActorId;
        }
        pub struct GetPair(());
        impl GetPair {
            #[allow(dead_code)]
            pub fn encode_call(token0: ActorId, token1: ActorId) -> Vec<u8> {
                <GetPair as ActionIo>::encode_call(&(token0, token1))
            }
        }
        impl ActionIo for GetPair {
            const ROUTE: &'static [u8] = &[
                28, 70, 97, 99, 116, 111, 114, 121, 28, 71, 101, 116, 80, 97, 105, 114,
            ];
            type Params = (ActorId, ActorId);
            type Reply = ActorId;
        }
        pub struct Pairs(());
        impl Pairs {
            #[allow(dead_code)]
            pub fn encode_call() -> Vec<u8> {
                <Pairs as ActionIo>::encode_call(&())
            }
        }
        impl ActionIo for Pairs {
            const ROUTE: &'static [u8] = &[
                28, 70, 97, 99, 116, 111, 114, 121, 20, 80, 97, 105, 114, 115,
            ];
            type Params = ();
            type Reply = Vec<((ActorId, ActorId), ActorId)>;
        }
        pub struct TreasuryId(());
        impl TreasuryId {
            #[allow(dead_code)]
            pub fn encode_call() -> Vec<u8> {
                <TreasuryId as ActionIo>::encode_call(&())
            }
        }
        impl ActionIo for TreasuryId {
            const ROUTE: &'static [u8] = &[
                28, 70, 97, 99, 116, 111, 114, 121, 40, 84, 114, 101, 97, 115, 117, 114, 121, 73,
                100,
            ];
            type Params = ();
            type Reply = ActorId;
        }
    }

    #[allow(dead_code)]
    #[cfg(not(target_arch = "wasm32"))]
    pub mod events {
        use super::*;
        use sails_rs::events::*;
        #[derive(PartialEq, Debug, Encode, Decode)]
        #[codec(crate = sails_rs::scale_codec)]
        pub enum FactoryEvents {
            PairCreated {
                token0: ActorId,
                token1: ActorId,
                pair_address: ActorId,
            },
        }
        impl EventIo for FactoryEvents {
            const ROUTE: &'static [u8] = &[28, 70, 97, 99, 116, 111, 114, 121];
            const EVENT_NAMES: &'static [&'static [u8]] =
                &[&[44, 80, 97, 105, 114, 67, 114, 101, 97, 116, 101, 100]];
            type Event = Self;
        }
        pub fn listener<R: Listener<Vec<u8>>>(remoting: R) -> impl Listener<FactoryEvents> {
            RemotingListener::<_, FactoryEvents>::new(remoting)
        }
    }
}
/// Config that will be used to send messages to the other programs or create programs.
#[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo)]
#[codec(crate = sails_rs::scale_codec)]
#[scale_info(crate = sails_rs::scale_info)]
pub struct Config {
    /// Gas limit for token operations. Token operations include:
    /// - Mint
    /// - Burn
    /// - TransferFrom
    pub gas_for_token_ops: u64,
    /// Gas to reserve for reply processing.
    pub gas_for_reply_deposit: u64,
    /// Timeout in blocks that current program will wait for reply from
    /// the other programs such as VFT
    pub reply_timeout: u32,
    pub gas_for_full_tx: u64,
    pub gas_for_pair_creation: u64,
    pub gas_to_change_fee_to: u64,
}

pub mod traits {
    use super::*;
    #[allow(dead_code)]
    pub trait FactoryClientFactory {
        type Args;
        #[allow(clippy::new_ret_no_self)]
        #[allow(clippy::wrong_self_convention)]
        fn new(
            &self,
            pair_id: CodeId,
            admin: ActorId,
            fee_to: ActorId,
            config: Config,
            treasury_id: ActorId,
        ) -> impl Activation<Args = Self::Args>;
    }

    #[allow(clippy::type_complexity)]
    pub trait Factory {
        type Args;
        fn add_pair(
            &mut self,
            token0: ActorId,
            token1: ActorId,
            pair_address: ActorId,
        ) -> impl Call<Output = (), Args = Self::Args>;
        fn change_fee_to(&mut self, fee_to: ActorId) -> impl Call<Output = (), Args = Self::Args>;
        fn change_treasury_id(
            &mut self,
            new_treasury_id: ActorId,
        ) -> impl Call<Output = (), Args = Self::Args>;
        fn create_pair(
            &mut self,
            token0: ActorId,
            token1: ActorId,
        ) -> impl Call<Output = (), Args = Self::Args>;
        fn fee_to(&self) -> impl Query<Output = ActorId, Args = Self::Args>;
        fn get_pair(
            &self,
            token0: ActorId,
            token1: ActorId,
        ) -> impl Query<Output = ActorId, Args = Self::Args>;
        fn pairs(
            &self,
        ) -> impl Query<Output = Vec<((ActorId, ActorId), ActorId)>, Args = Self::Args>;
        fn treasury_id(&self) -> impl Query<Output = ActorId, Args = Self::Args>;
    }
}
