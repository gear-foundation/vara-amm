// Code generated by sails-client-gen. DO NOT EDIT.
#[allow(unused_imports)]
use sails_rs::collections::BTreeMap;
#[allow(unused_imports)]
use sails_rs::{
    String,
    calls::{Activation, Call, Query, Remoting, RemotingAction},
    prelude::*,
};
pub struct PairClientFactory<R> {
    #[allow(dead_code)]
    remoting: R,
}
impl<R> PairClientFactory<R> {
    #[allow(unused)]
    pub fn new(remoting: R) -> Self {
        Self { remoting }
    }
}
impl<R: Remoting + Clone> traits::PairClientFactory for PairClientFactory<R> {
    type Args = R::Args;
    fn new(
        &self,
        config: Config,
        token0: ActorId,
        token1: ActorId,
        fee_to: ActorId,
        treasury_id: ActorId,
        admin_id: ActorId,
    ) -> impl Activation<Args = R::Args> {
        RemotingAction::<_, pair_client_factory::io::New>::new(
            self.remoting.clone(),
            (config, token0, token1, fee_to, treasury_id, admin_id),
        )
    }
}

pub mod pair_client_factory {
    use super::*;
    pub mod io {
        use super::*;
        use sails_rs::calls::ActionIo;
        pub struct New(());
        impl New {
            #[allow(dead_code)]
            pub fn encode_call(
                config: super::Config,
                token0: ActorId,
                token1: ActorId,
                fee_to: ActorId,
                treasury_id: ActorId,
                admin_id: ActorId,
            ) -> Vec<u8> {
                <New as ActionIo>::encode_call(&(
                    config,
                    token0,
                    token1,
                    fee_to,
                    treasury_id,
                    admin_id,
                ))
            }
        }
        impl ActionIo for New {
            const ROUTE: &'static [u8] = &[12, 78, 101, 119];
            type Params = (super::Config, ActorId, ActorId, ActorId, ActorId, ActorId);
            type Reply = ();
        }
    }
}
pub struct Pair<R> {
    remoting: R,
}
impl<R> Pair<R> {
    pub fn new(remoting: R) -> Self {
        Self { remoting }
    }
}
impl<R: Remoting + Clone> traits::Pair for Pair<R> {
    type Args = R::Args;
    fn add_liquidity(
        &mut self,
        amount_a_desired: U256,
        amount_b_desired: U256,
        amount_a_min: U256,
        amount_b_min: U256,
        deadline: u64,
    ) -> impl Call<Output = (), Args = R::Args> {
        RemotingAction::<_, pair::io::AddLiquidity>::new(
            self.remoting.clone(),
            (
                amount_a_desired,
                amount_b_desired,
                amount_a_min,
                amount_b_min,
                deadline,
            ),
        )
    }
    fn change_fee_to(&mut self, new_fee_to: ActorId) -> impl Call<Output = (), Args = R::Args> {
        RemotingAction::<_, pair::io::ChangeFeeTo>::new(self.remoting.clone(), new_fee_to)
    }
    fn change_treasury_id(
        &mut self,
        new_treasury_id: ActorId,
    ) -> impl Call<Output = (), Args = R::Args> {
        RemotingAction::<_, pair::io::ChangeTreasuryId>::new(self.remoting.clone(), new_treasury_id)
    }
    /// Migrates all pool liquidity and accrued treasury fees to a target address.
    ///
    /// After migration:
    /// - `reserve0`, `reserve1`, `k_last`,
    /// `accrued_treasury_fee0`, `accrued_treasury_fee1` are reset to zero.
    ///
    /// NOTE:
    /// - Intended for final pool shutdown / migration to a new contract.
    /// - Should be callable only by an admin
    fn migrate_all_liquidity(&mut self, target: ActorId) -> impl Call<Output = (), Args = R::Args> {
        RemotingAction::<_, pair::io::MigrateAllLiquidity>::new(self.remoting.clone(), target)
    }
    /// Removes liquidity from the AMM pool
    ///
    /// # Parameters
    /// * `liquidity` - Amount of LP tokens to burn
    /// * `amount_a_min` - Minimum amount of token A to receive (slippage protection)
    /// * `amount_b_min` - Minimum amount of token B to receive (slippage protection)
    /// * `deadline` - Timestamp after which the transaction is considered invalid
    ///
    /// # Algorithm
    /// 1. Validates deadline and user's LP token balance
    /// 2. Mints accumulated protocol fees (modifies state permanently)
    /// 3. Calculates proportional amounts of tokens A and B to return
    /// 4. Validates amounts against minimum thresholds
    /// 5. Burns user's LP tokens and transfers underlying tokens back
    /// 6. Updates pool reserves
    fn remove_liquidity(
        &mut self,
        liquidity: U256,
        amount_a_min: U256,
        amount_b_min: U256,
        deadline: u64,
    ) -> impl Call<Output = (), Args = R::Args> {
        RemotingAction::<_, pair::io::RemoveLiquidity>::new(
            self.remoting.clone(),
            (liquidity, amount_a_min, amount_b_min, deadline),
        )
    }
    fn send_treasury_fees(&mut self) -> impl Call<Output = (), Args = R::Args> {
        RemotingAction::<_, pair::io::SendTreasuryFees>::new(self.remoting.clone(), ())
    }
    fn set_lock(&mut self, lock: bool) -> impl Call<Output = (), Args = R::Args> {
        RemotingAction::<_, pair::io::SetLock>::new(self.remoting.clone(), lock)
    }
    /// Swaps an exact amount of input tokens for as many output tokens as possible in a single pair.
    /// Direction is specified by is_token0_to_token1 (true for token0 -> token1, false for token1 -> token0).
    /// Combines high-level swap logic with low-level swap execution for a single-contract setup.
    /// # Arguments
    /// * `amount_in` - Exact amount of input token to swap
    /// * `amount_out_min` - Minimum amount of output token expected (slippage protection)
    /// * `is_token0_to_token1` - Direction of swap (true: token0 to token1, false: token1 to token0)
    /// * `deadline` - Unix timestamp after which the transaction will revert
    fn swap_exact_tokens_for_tokens(
        &mut self,
        amount_in: U256,
        amount_out_min: U256,
        is_token0_to_token1: bool,
        deadline: u64,
    ) -> impl Call<Output = (), Args = R::Args> {
        RemotingAction::<_, pair::io::SwapExactTokensForTokens>::new(
            self.remoting.clone(),
            (amount_in, amount_out_min, is_token0_to_token1, deadline),
        )
    }
    /// Swaps as few input tokens as possible for an exact amount of output tokens in a single pair.
    /// Direction is specified by is_token0_to_token1 (true for token0 -> token1, false for token1 -> token0).
    /// Combines high-level swap logic with low-level swap execution for a single-contract setup.
    /// # Arguments
    /// * `amount_out` - Exact amount of output token desired
    /// * `amount_in_max` - Maximum amount of input token willing to pay (slippage protection)
    /// * `is_token0_to_token1` - Direction of swap (true: token0 to token1, false: token1 to token0)
    /// * `deadline` - Unix timestamp after which the transaction will revert
    fn swap_tokens_for_exact_tokens(
        &mut self,
        amount_out: U256,
        amount_in_max: U256,
        is_token0_to_token1: bool,
        deadline: u64,
    ) -> impl Call<Output = (), Args = R::Args> {
        RemotingAction::<_, pair::io::SwapTokensForExactTokens>::new(
            self.remoting.clone(),
            (amount_out, amount_in_max, is_token0_to_token1, deadline),
        )
    }
    /// Calculates accumulated swap fees for a specific LP provider.
    ///
    /// Similar to calculate_lp_fee, but returns the share of LP fees for a user with a given
    /// LP token balance (pro-rata based on `user_lp_balance / total_supply`). Returns 0 if no growth.
    fn calculate_lp_user_fee(&self, user: ActorId) -> impl Query<Output = U256, Args = R::Args> {
        RemotingAction::<_, pair::io::CalculateLpUserFee>::new(self.remoting.clone(), user)
    }
    /// Calculates protocol fees for the liquidity pool, similar to Uniswap V2, without minting.
    ///
    /// This function checks if protocol fees are enabled (via `fee_to` address) and calculates
    /// the growth in pool reserves due to accumulated swap fees (0.3% per swap, with 1/6 or
    /// 0.05% going to the protocol). Returns the amount of new liquidity tokens (LP tokens)
    /// that would be minted to the `fee_to` address, proportional to the increase in the square root
    /// of the constant product (`reserve0 * reserve1`). If protocol fees are disabled or no growth,
    /// returns 0.
    ///
    /// Can be called for estimation or off-chain calculations. Does not modify state.
    fn calculate_protocol_fee(&self) -> impl Query<Output = U256, Args = R::Args> {
        RemotingAction::<_, pair::io::CalculateProtocolFee>::new(self.remoting.clone(), ())
    }
    /// Calculates the amounts of token A and B a user would receive when removing liquidity.
    ///
    /// This function simulates the removal of liquidity by burning a given amount of LP tokens.
    /// It accounts for protocol fees (by simulating mint_fee dilution), calculates pro-rata shares
    /// based on reserves (assuming they include swap fees), and sorts amounts by token_a/token_b.
    /// Does not modify state or perform any transactions.
    fn calculate_remove_liquidity(
        &self,
        liquidity: U256,
    ) -> impl Query<Output = (U256, U256), Args = R::Args> {
        RemotingAction::<_, pair::io::CalculateRemoveLiquidity>::new(
            self.remoting.clone(),
            liquidity,
        )
    }
    /// Calculates the required input amount for a desired output, given current reserves,
    /// including both the internal 0.3% swap fee (Uniswap-style) and the optional
    /// treasury fee in the input token.
    ///
    /// - First, the function determines how much must actually enter the pool
    /// (`amount_in_for_pool`) using the standard Uniswap 0.3% math.
    /// - Then, if treasury fee is enabled, it computes a higher total input
    /// `amount_in_total` such that:
    /// amount_in_for_pool = amount_in_total * (1 - treasury_fee_bps / 10_000)
    /// and the difference `amount_in_total - amount_in_for_pool` is the treasury fee.
    /// - If treasury is disabled, the result matches classic Uniswap V2
    /// `getAmountIn` with 0.3% fee.
    ///
    /// # Arguments
    /// * `amount_out` - Desired amount of output asset
    /// * `is_token0_to_token1` - Direction of swap (true: token0 to token1, false: token1 to token0)
    fn get_amount_in(
        &self,
        amount_out: U256,
        is_token0_to_token1: bool,
    ) -> impl Query<Output = U256, Args = R::Args> {
        RemotingAction::<_, pair::io::GetAmountIn>::new(
            self.remoting.clone(),
            (amount_out, is_token0_to_token1),
        )
    }
    /// Calculates the expected output amount for a swap, given the input amount and
    /// current reserves, including both the internal 0.3% swap fee (Uniswap-style)
    /// and the optional treasury fee in the input token.
    /// Uses floor division
    ///
    /// - If `treasury` is configured (non-zero address), the input is split into:
    /// * a small part reserved as treasury fee (e.g. 0.05%), and
    /// * the remaining part that actually enters the pool and is priced
    /// with the Uniswap V2 formula (0.3% fee via 997/1000 multiplier).
    /// - If `treasury` is not configured (zero address), the behavior matches
    /// the classic Uniswap V2 `getAmountOut` with 0.3% fee.
    ///
    /// # Arguments
    /// * `amount_in` - Amount of input asset being swapped
    /// * `is_token0_to_token1` - Direction of swap (true: token0 to token1, false: token1 to token0)
    fn get_amount_out(
        &self,
        amount_in: U256,
        is_token0_to_token1: bool,
    ) -> impl Query<Output = U256, Args = R::Args> {
        RemotingAction::<_, pair::io::GetAmountOut>::new(
            self.remoting.clone(),
            (amount_in, is_token0_to_token1),
        )
    }
    fn get_reserves(&self) -> impl Query<Output = (U256, U256), Args = R::Args> {
        RemotingAction::<_, pair::io::GetReserves>::new(self.remoting.clone(), ())
    }
    fn get_tokens(&self) -> impl Query<Output = (ActorId, ActorId), Args = R::Args> {
        RemotingAction::<_, pair::io::GetTokens>::new(self.remoting.clone(), ())
    }
    /// Returns basic treasury info:
    /// - treasury address,
    /// - accrued fee in token0,
    /// - accrued fee in token1.
    fn get_treasury_info(&self) -> impl Query<Output = (ActorId, U256, U256), Args = R::Args> {
        RemotingAction::<_, pair::io::GetTreasuryInfo>::new(self.remoting.clone(), ())
    }
    fn lock(&self) -> impl Query<Output = bool, Args = R::Args> {
        RemotingAction::<_, pair::io::Lock>::new(self.remoting.clone(), ())
    }
    fn migrated(&self) -> impl Query<Output = bool, Args = R::Args> {
        RemotingAction::<_, pair::io::Migrated>::new(self.remoting.clone(), ())
    }
    fn msgs_in_msg_tracker(
        &self,
    ) -> impl Query<Output = Vec<(MessageId, MessageStatus)>, Args = R::Args> {
        RemotingAction::<_, pair::io::MsgsInMsgTracker>::new(self.remoting.clone(), ())
    }
    fn treasury_id(&self) -> impl Query<Output = ActorId, Args = R::Args> {
        RemotingAction::<_, pair::io::TreasuryId>::new(self.remoting.clone(), ())
    }
}

pub mod pair {
    use super::*;

    pub mod io {
        use super::*;
        use sails_rs::calls::ActionIo;
        pub struct AddLiquidity(());
        impl AddLiquidity {
            #[allow(dead_code)]
            pub fn encode_call(
                amount_a_desired: U256,
                amount_b_desired: U256,
                amount_a_min: U256,
                amount_b_min: U256,
                deadline: u64,
            ) -> Vec<u8> {
                <AddLiquidity as ActionIo>::encode_call(&(
                    amount_a_desired,
                    amount_b_desired,
                    amount_a_min,
                    amount_b_min,
                    deadline,
                ))
            }
        }
        impl ActionIo for AddLiquidity {
            const ROUTE: &'static [u8] = &[
                16, 80, 97, 105, 114, 48, 65, 100, 100, 76, 105, 113, 117, 105, 100, 105, 116, 121,
            ];
            type Params = (U256, U256, U256, U256, u64);
            type Reply = ();
        }
        pub struct ChangeFeeTo(());
        impl ChangeFeeTo {
            #[allow(dead_code)]
            pub fn encode_call(new_fee_to: ActorId) -> Vec<u8> {
                <ChangeFeeTo as ActionIo>::encode_call(&new_fee_to)
            }
        }
        impl ActionIo for ChangeFeeTo {
            const ROUTE: &'static [u8] = &[
                16, 80, 97, 105, 114, 44, 67, 104, 97, 110, 103, 101, 70, 101, 101, 84, 111,
            ];
            type Params = ActorId;
            type Reply = ();
        }
        pub struct ChangeTreasuryId(());
        impl ChangeTreasuryId {
            #[allow(dead_code)]
            pub fn encode_call(new_treasury_id: ActorId) -> Vec<u8> {
                <ChangeTreasuryId as ActionIo>::encode_call(&new_treasury_id)
            }
        }
        impl ActionIo for ChangeTreasuryId {
            const ROUTE: &'static [u8] = &[
                16, 80, 97, 105, 114, 64, 67, 104, 97, 110, 103, 101, 84, 114, 101, 97, 115, 117,
                114, 121, 73, 100,
            ];
            type Params = ActorId;
            type Reply = ();
        }
        pub struct MigrateAllLiquidity(());
        impl MigrateAllLiquidity {
            #[allow(dead_code)]
            pub fn encode_call(target: ActorId) -> Vec<u8> {
                <MigrateAllLiquidity as ActionIo>::encode_call(&target)
            }
        }
        impl ActionIo for MigrateAllLiquidity {
            const ROUTE: &'static [u8] = &[
                16, 80, 97, 105, 114, 76, 77, 105, 103, 114, 97, 116, 101, 65, 108, 108, 76, 105,
                113, 117, 105, 100, 105, 116, 121,
            ];
            type Params = ActorId;
            type Reply = ();
        }
        pub struct RemoveLiquidity(());
        impl RemoveLiquidity {
            #[allow(dead_code)]
            pub fn encode_call(
                liquidity: U256,
                amount_a_min: U256,
                amount_b_min: U256,
                deadline: u64,
            ) -> Vec<u8> {
                <RemoveLiquidity as ActionIo>::encode_call(&(
                    liquidity,
                    amount_a_min,
                    amount_b_min,
                    deadline,
                ))
            }
        }
        impl ActionIo for RemoveLiquidity {
            const ROUTE: &'static [u8] = &[
                16, 80, 97, 105, 114, 60, 82, 101, 109, 111, 118, 101, 76, 105, 113, 117, 105, 100,
                105, 116, 121,
            ];
            type Params = (U256, U256, U256, u64);
            type Reply = ();
        }
        pub struct SendTreasuryFees(());
        impl SendTreasuryFees {
            #[allow(dead_code)]
            pub fn encode_call() -> Vec<u8> {
                <SendTreasuryFees as ActionIo>::encode_call(&())
            }
        }
        impl ActionIo for SendTreasuryFees {
            const ROUTE: &'static [u8] = &[
                16, 80, 97, 105, 114, 64, 83, 101, 110, 100, 84, 114, 101, 97, 115, 117, 114, 121,
                70, 101, 101, 115,
            ];
            type Params = ();
            type Reply = ();
        }
        pub struct SetLock(());
        impl SetLock {
            #[allow(dead_code)]
            pub fn encode_call(lock: bool) -> Vec<u8> {
                <SetLock as ActionIo>::encode_call(&lock)
            }
        }
        impl ActionIo for SetLock {
            const ROUTE: &'static [u8] =
                &[16, 80, 97, 105, 114, 28, 83, 101, 116, 76, 111, 99, 107];
            type Params = bool;
            type Reply = ();
        }
        pub struct SwapExactTokensForTokens(());
        impl SwapExactTokensForTokens {
            #[allow(dead_code)]
            pub fn encode_call(
                amount_in: U256,
                amount_out_min: U256,
                is_token0_to_token1: bool,
                deadline: u64,
            ) -> Vec<u8> {
                <SwapExactTokensForTokens as ActionIo>::encode_call(&(
                    amount_in,
                    amount_out_min,
                    is_token0_to_token1,
                    deadline,
                ))
            }
        }
        impl ActionIo for SwapExactTokensForTokens {
            const ROUTE: &'static [u8] = &[
                16, 80, 97, 105, 114, 96, 83, 119, 97, 112, 69, 120, 97, 99, 116, 84, 111, 107,
                101, 110, 115, 70, 111, 114, 84, 111, 107, 101, 110, 115,
            ];
            type Params = (U256, U256, bool, u64);
            type Reply = ();
        }
        pub struct SwapTokensForExactTokens(());
        impl SwapTokensForExactTokens {
            #[allow(dead_code)]
            pub fn encode_call(
                amount_out: U256,
                amount_in_max: U256,
                is_token0_to_token1: bool,
                deadline: u64,
            ) -> Vec<u8> {
                <SwapTokensForExactTokens as ActionIo>::encode_call(&(
                    amount_out,
                    amount_in_max,
                    is_token0_to_token1,
                    deadline,
                ))
            }
        }
        impl ActionIo for SwapTokensForExactTokens {
            const ROUTE: &'static [u8] = &[
                16, 80, 97, 105, 114, 96, 83, 119, 97, 112, 84, 111, 107, 101, 110, 115, 70, 111,
                114, 69, 120, 97, 99, 116, 84, 111, 107, 101, 110, 115,
            ];
            type Params = (U256, U256, bool, u64);
            type Reply = ();
        }
        pub struct CalculateLpUserFee(());
        impl CalculateLpUserFee {
            #[allow(dead_code)]
            pub fn encode_call(user: ActorId) -> Vec<u8> {
                <CalculateLpUserFee as ActionIo>::encode_call(&user)
            }
        }
        impl ActionIo for CalculateLpUserFee {
            const ROUTE: &'static [u8] = &[
                16, 80, 97, 105, 114, 72, 67, 97, 108, 99, 117, 108, 97, 116, 101, 76, 112, 85,
                115, 101, 114, 70, 101, 101,
            ];
            type Params = ActorId;
            type Reply = U256;
        }
        pub struct CalculateProtocolFee(());
        impl CalculateProtocolFee {
            #[allow(dead_code)]
            pub fn encode_call() -> Vec<u8> {
                <CalculateProtocolFee as ActionIo>::encode_call(&())
            }
        }
        impl ActionIo for CalculateProtocolFee {
            const ROUTE: &'static [u8] = &[
                16, 80, 97, 105, 114, 80, 67, 97, 108, 99, 117, 108, 97, 116, 101, 80, 114, 111,
                116, 111, 99, 111, 108, 70, 101, 101,
            ];
            type Params = ();
            type Reply = U256;
        }
        pub struct CalculateRemoveLiquidity(());
        impl CalculateRemoveLiquidity {
            #[allow(dead_code)]
            pub fn encode_call(liquidity: U256) -> Vec<u8> {
                <CalculateRemoveLiquidity as ActionIo>::encode_call(&liquidity)
            }
        }
        impl ActionIo for CalculateRemoveLiquidity {
            const ROUTE: &'static [u8] = &[
                16, 80, 97, 105, 114, 96, 67, 97, 108, 99, 117, 108, 97, 116, 101, 82, 101, 109,
                111, 118, 101, 76, 105, 113, 117, 105, 100, 105, 116, 121,
            ];
            type Params = U256;
            type Reply = (U256, U256);
        }
        pub struct GetAmountIn(());
        impl GetAmountIn {
            #[allow(dead_code)]
            pub fn encode_call(amount_out: U256, is_token0_to_token1: bool) -> Vec<u8> {
                <GetAmountIn as ActionIo>::encode_call(&(amount_out, is_token0_to_token1))
            }
        }
        impl ActionIo for GetAmountIn {
            const ROUTE: &'static [u8] = &[
                16, 80, 97, 105, 114, 44, 71, 101, 116, 65, 109, 111, 117, 110, 116, 73, 110,
            ];
            type Params = (U256, bool);
            type Reply = U256;
        }
        pub struct GetAmountOut(());
        impl GetAmountOut {
            #[allow(dead_code)]
            pub fn encode_call(amount_in: U256, is_token0_to_token1: bool) -> Vec<u8> {
                <GetAmountOut as ActionIo>::encode_call(&(amount_in, is_token0_to_token1))
            }
        }
        impl ActionIo for GetAmountOut {
            const ROUTE: &'static [u8] = &[
                16, 80, 97, 105, 114, 48, 71, 101, 116, 65, 109, 111, 117, 110, 116, 79, 117, 116,
            ];
            type Params = (U256, bool);
            type Reply = U256;
        }
        pub struct GetReserves(());
        impl GetReserves {
            #[allow(dead_code)]
            pub fn encode_call() -> Vec<u8> {
                <GetReserves as ActionIo>::encode_call(&())
            }
        }
        impl ActionIo for GetReserves {
            const ROUTE: &'static [u8] = &[
                16, 80, 97, 105, 114, 44, 71, 101, 116, 82, 101, 115, 101, 114, 118, 101, 115,
            ];
            type Params = ();
            type Reply = (U256, U256);
        }
        pub struct GetTokens(());
        impl GetTokens {
            #[allow(dead_code)]
            pub fn encode_call() -> Vec<u8> {
                <GetTokens as ActionIo>::encode_call(&())
            }
        }
        impl ActionIo for GetTokens {
            const ROUTE: &'static [u8] = &[
                16, 80, 97, 105, 114, 36, 71, 101, 116, 84, 111, 107, 101, 110, 115,
            ];
            type Params = ();
            type Reply = (ActorId, ActorId);
        }
        pub struct GetTreasuryInfo(());
        impl GetTreasuryInfo {
            #[allow(dead_code)]
            pub fn encode_call() -> Vec<u8> {
                <GetTreasuryInfo as ActionIo>::encode_call(&())
            }
        }
        impl ActionIo for GetTreasuryInfo {
            const ROUTE: &'static [u8] = &[
                16, 80, 97, 105, 114, 60, 71, 101, 116, 84, 114, 101, 97, 115, 117, 114, 121, 73,
                110, 102, 111,
            ];
            type Params = ();
            type Reply = (ActorId, U256, U256);
        }
        pub struct Lock(());
        impl Lock {
            #[allow(dead_code)]
            pub fn encode_call() -> Vec<u8> {
                <Lock as ActionIo>::encode_call(&())
            }
        }
        impl ActionIo for Lock {
            const ROUTE: &'static [u8] = &[16, 80, 97, 105, 114, 16, 76, 111, 99, 107];
            type Params = ();
            type Reply = bool;
        }
        pub struct Migrated(());
        impl Migrated {
            #[allow(dead_code)]
            pub fn encode_call() -> Vec<u8> {
                <Migrated as ActionIo>::encode_call(&())
            }
        }
        impl ActionIo for Migrated {
            const ROUTE: &'static [u8] = &[
                16, 80, 97, 105, 114, 32, 77, 105, 103, 114, 97, 116, 101, 100,
            ];
            type Params = ();
            type Reply = bool;
        }
        pub struct MsgsInMsgTracker(());
        impl MsgsInMsgTracker {
            #[allow(dead_code)]
            pub fn encode_call() -> Vec<u8> {
                <MsgsInMsgTracker as ActionIo>::encode_call(&())
            }
        }
        impl ActionIo for MsgsInMsgTracker {
            const ROUTE: &'static [u8] = &[
                16, 80, 97, 105, 114, 64, 77, 115, 103, 115, 73, 110, 77, 115, 103, 84, 114, 97,
                99, 107, 101, 114,
            ];
            type Params = ();
            type Reply = Vec<(MessageId, super::MessageStatus)>;
        }
        pub struct TreasuryId(());
        impl TreasuryId {
            #[allow(dead_code)]
            pub fn encode_call() -> Vec<u8> {
                <TreasuryId as ActionIo>::encode_call(&())
            }
        }
        impl ActionIo for TreasuryId {
            const ROUTE: &'static [u8] = &[
                16, 80, 97, 105, 114, 40, 84, 114, 101, 97, 115, 117, 114, 121, 73, 100,
            ];
            type Params = ();
            type Reply = ActorId;
        }
    }

    #[allow(dead_code)]
    #[cfg(not(target_arch = "wasm32"))]
    pub mod events {
        use super::*;
        use sails_rs::events::*;
        #[derive(PartialEq, Debug, Encode, Decode)]
        #[codec(crate = sails_rs::scale_codec)]
        pub enum PairEvents {
            LiquidityAdded {
                user_id: ActorId,
                amount_a: U256,
                amount_b: U256,
                liquidity: U256,
            },
            Swap {
                user_id: ActorId,
                amount_in: U256,
                amount_out: U256,
                is_token0_to_token1: bool,
            },
            LiquidityRemoved {
                user_id: ActorId,
                amount_a: U256,
                amount_b: U256,
                liquidity: U256,
            },
            TreasuryFeesCollected {
                treasury_id: ActorId,
                amount_a: U256,
                amount_b: U256,
            },
            LiquidityMigrated {
                to: ActorId,
                amount0: U256,
                amount1: U256,
            },
        }
        impl EventIo for PairEvents {
            const ROUTE: &'static [u8] = &[16, 80, 97, 105, 114];
            const EVENT_NAMES: &'static [&'static [u8]] = &[
                &[
                    56, 76, 105, 113, 117, 105, 100, 105, 116, 121, 65, 100, 100, 101, 100,
                ],
                &[16, 83, 119, 97, 112],
                &[
                    64, 76, 105, 113, 117, 105, 100, 105, 116, 121, 82, 101, 109, 111, 118, 101,
                    100,
                ],
                &[
                    84, 84, 114, 101, 97, 115, 117, 114, 121, 70, 101, 101, 115, 67, 111, 108, 108,
                    101, 99, 116, 101, 100,
                ],
                &[
                    68, 76, 105, 113, 117, 105, 100, 105, 116, 121, 77, 105, 103, 114, 97, 116,
                    101, 100,
                ],
            ];
            type Event = Self;
        }
        pub fn listener<R: Listener<Vec<u8>>>(remoting: R) -> impl Listener<PairEvents> {
            RemotingListener::<_, PairEvents>::new(remoting)
        }
    }
}
pub struct Vft<R> {
    remoting: R,
}
impl<R> Vft<R> {
    pub fn new(remoting: R) -> Self {
        Self { remoting }
    }
}
impl<R: Remoting + Clone> traits::Vft for Vft<R> {
    type Args = R::Args;
    fn grant_admin_role(&mut self, to: ActorId) -> impl Call<Output = (), Args = R::Args> {
        RemotingAction::<_, vft::io::GrantAdminRole>::new(self.remoting.clone(), to)
    }
    fn grant_burner_role(&mut self, to: ActorId) -> impl Call<Output = (), Args = R::Args> {
        RemotingAction::<_, vft::io::GrantBurnerRole>::new(self.remoting.clone(), to)
    }
    fn grant_minter_role(&mut self, to: ActorId) -> impl Call<Output = (), Args = R::Args> {
        RemotingAction::<_, vft::io::GrantMinterRole>::new(self.remoting.clone(), to)
    }
    fn revoke_admin_role(&mut self, from: ActorId) -> impl Call<Output = (), Args = R::Args> {
        RemotingAction::<_, vft::io::RevokeAdminRole>::new(self.remoting.clone(), from)
    }
    fn revoke_burner_role(&mut self, from: ActorId) -> impl Call<Output = (), Args = R::Args> {
        RemotingAction::<_, vft::io::RevokeBurnerRole>::new(self.remoting.clone(), from)
    }
    fn revoke_minter_role(&mut self, from: ActorId) -> impl Call<Output = (), Args = R::Args> {
        RemotingAction::<_, vft::io::RevokeMinterRole>::new(self.remoting.clone(), from)
    }
    fn approve(
        &mut self,
        spender: ActorId,
        value: U256,
    ) -> impl Call<Output = bool, Args = R::Args> {
        RemotingAction::<_, vft::io::Approve>::new(self.remoting.clone(), (spender, value))
    }
    fn transfer(&mut self, to: ActorId, value: U256) -> impl Call<Output = bool, Args = R::Args> {
        RemotingAction::<_, vft::io::Transfer>::new(self.remoting.clone(), (to, value))
    }
    fn transfer_from(
        &mut self,
        from: ActorId,
        to: ActorId,
        value: U256,
    ) -> impl Call<Output = bool, Args = R::Args> {
        RemotingAction::<_, vft::io::TransferFrom>::new(self.remoting.clone(), (from, to, value))
    }
    fn admins(&self) -> impl Query<Output = Vec<ActorId>, Args = R::Args> {
        RemotingAction::<_, vft::io::Admins>::new(self.remoting.clone(), ())
    }
    fn burners(&self) -> impl Query<Output = Vec<ActorId>, Args = R::Args> {
        RemotingAction::<_, vft::io::Burners>::new(self.remoting.clone(), ())
    }
    fn minters(&self) -> impl Query<Output = Vec<ActorId>, Args = R::Args> {
        RemotingAction::<_, vft::io::Minters>::new(self.remoting.clone(), ())
    }
    fn allowance(
        &self,
        owner: ActorId,
        spender: ActorId,
    ) -> impl Query<Output = U256, Args = R::Args> {
        RemotingAction::<_, vft::io::Allowance>::new(self.remoting.clone(), (owner, spender))
    }
    fn balance_of(&self, account: ActorId) -> impl Query<Output = U256, Args = R::Args> {
        RemotingAction::<_, vft::io::BalanceOf>::new(self.remoting.clone(), account)
    }
    fn decimals(&self) -> impl Query<Output = u8, Args = R::Args> {
        RemotingAction::<_, vft::io::Decimals>::new(self.remoting.clone(), ())
    }
    fn name(&self) -> impl Query<Output = String, Args = R::Args> {
        RemotingAction::<_, vft::io::Name>::new(self.remoting.clone(), ())
    }
    fn symbol(&self) -> impl Query<Output = String, Args = R::Args> {
        RemotingAction::<_, vft::io::Symbol>::new(self.remoting.clone(), ())
    }
    fn total_supply(&self) -> impl Query<Output = U256, Args = R::Args> {
        RemotingAction::<_, vft::io::TotalSupply>::new(self.remoting.clone(), ())
    }
}

pub mod vft {
    use super::*;

    pub mod io {
        use super::*;
        use sails_rs::calls::ActionIo;
        pub struct GrantAdminRole(());
        impl GrantAdminRole {
            #[allow(dead_code)]
            pub fn encode_call(to: ActorId) -> Vec<u8> {
                <GrantAdminRole as ActionIo>::encode_call(&to)
            }
        }
        impl ActionIo for GrantAdminRole {
            const ROUTE: &'static [u8] = &[
                12, 86, 102, 116, 56, 71, 114, 97, 110, 116, 65, 100, 109, 105, 110, 82, 111, 108,
                101,
            ];
            type Params = ActorId;
            type Reply = ();
        }
        pub struct GrantBurnerRole(());
        impl GrantBurnerRole {
            #[allow(dead_code)]
            pub fn encode_call(to: ActorId) -> Vec<u8> {
                <GrantBurnerRole as ActionIo>::encode_call(&to)
            }
        }
        impl ActionIo for GrantBurnerRole {
            const ROUTE: &'static [u8] = &[
                12, 86, 102, 116, 60, 71, 114, 97, 110, 116, 66, 117, 114, 110, 101, 114, 82, 111,
                108, 101,
            ];
            type Params = ActorId;
            type Reply = ();
        }
        pub struct GrantMinterRole(());
        impl GrantMinterRole {
            #[allow(dead_code)]
            pub fn encode_call(to: ActorId) -> Vec<u8> {
                <GrantMinterRole as ActionIo>::encode_call(&to)
            }
        }
        impl ActionIo for GrantMinterRole {
            const ROUTE: &'static [u8] = &[
                12, 86, 102, 116, 60, 71, 114, 97, 110, 116, 77, 105, 110, 116, 101, 114, 82, 111,
                108, 101,
            ];
            type Params = ActorId;
            type Reply = ();
        }
        pub struct RevokeAdminRole(());
        impl RevokeAdminRole {
            #[allow(dead_code)]
            pub fn encode_call(from: ActorId) -> Vec<u8> {
                <RevokeAdminRole as ActionIo>::encode_call(&from)
            }
        }
        impl ActionIo for RevokeAdminRole {
            const ROUTE: &'static [u8] = &[
                12, 86, 102, 116, 60, 82, 101, 118, 111, 107, 101, 65, 100, 109, 105, 110, 82, 111,
                108, 101,
            ];
            type Params = ActorId;
            type Reply = ();
        }
        pub struct RevokeBurnerRole(());
        impl RevokeBurnerRole {
            #[allow(dead_code)]
            pub fn encode_call(from: ActorId) -> Vec<u8> {
                <RevokeBurnerRole as ActionIo>::encode_call(&from)
            }
        }
        impl ActionIo for RevokeBurnerRole {
            const ROUTE: &'static [u8] = &[
                12, 86, 102, 116, 64, 82, 101, 118, 111, 107, 101, 66, 117, 114, 110, 101, 114, 82,
                111, 108, 101,
            ];
            type Params = ActorId;
            type Reply = ();
        }
        pub struct RevokeMinterRole(());
        impl RevokeMinterRole {
            #[allow(dead_code)]
            pub fn encode_call(from: ActorId) -> Vec<u8> {
                <RevokeMinterRole as ActionIo>::encode_call(&from)
            }
        }
        impl ActionIo for RevokeMinterRole {
            const ROUTE: &'static [u8] = &[
                12, 86, 102, 116, 64, 82, 101, 118, 111, 107, 101, 77, 105, 110, 116, 101, 114, 82,
                111, 108, 101,
            ];
            type Params = ActorId;
            type Reply = ();
        }
        pub struct Approve(());
        impl Approve {
            #[allow(dead_code)]
            pub fn encode_call(spender: ActorId, value: U256) -> Vec<u8> {
                <Approve as ActionIo>::encode_call(&(spender, value))
            }
        }
        impl ActionIo for Approve {
            const ROUTE: &'static [u8] = &[12, 86, 102, 116, 28, 65, 112, 112, 114, 111, 118, 101];
            type Params = (ActorId, U256);
            type Reply = bool;
        }
        pub struct Transfer(());
        impl Transfer {
            #[allow(dead_code)]
            pub fn encode_call(to: ActorId, value: U256) -> Vec<u8> {
                <Transfer as ActionIo>::encode_call(&(to, value))
            }
        }
        impl ActionIo for Transfer {
            const ROUTE: &'static [u8] =
                &[12, 86, 102, 116, 32, 84, 114, 97, 110, 115, 102, 101, 114];
            type Params = (ActorId, U256);
            type Reply = bool;
        }
        pub struct TransferFrom(());
        impl TransferFrom {
            #[allow(dead_code)]
            pub fn encode_call(from: ActorId, to: ActorId, value: U256) -> Vec<u8> {
                <TransferFrom as ActionIo>::encode_call(&(from, to, value))
            }
        }
        impl ActionIo for TransferFrom {
            const ROUTE: &'static [u8] = &[
                12, 86, 102, 116, 48, 84, 114, 97, 110, 115, 102, 101, 114, 70, 114, 111, 109,
            ];
            type Params = (ActorId, ActorId, U256);
            type Reply = bool;
        }
        pub struct Admins(());
        impl Admins {
            #[allow(dead_code)]
            pub fn encode_call() -> Vec<u8> {
                <Admins as ActionIo>::encode_call(&())
            }
        }
        impl ActionIo for Admins {
            const ROUTE: &'static [u8] = &[12, 86, 102, 116, 24, 65, 100, 109, 105, 110, 115];
            type Params = ();
            type Reply = Vec<ActorId>;
        }
        pub struct Burners(());
        impl Burners {
            #[allow(dead_code)]
            pub fn encode_call() -> Vec<u8> {
                <Burners as ActionIo>::encode_call(&())
            }
        }
        impl ActionIo for Burners {
            const ROUTE: &'static [u8] = &[12, 86, 102, 116, 28, 66, 117, 114, 110, 101, 114, 115];
            type Params = ();
            type Reply = Vec<ActorId>;
        }
        pub struct Minters(());
        impl Minters {
            #[allow(dead_code)]
            pub fn encode_call() -> Vec<u8> {
                <Minters as ActionIo>::encode_call(&())
            }
        }
        impl ActionIo for Minters {
            const ROUTE: &'static [u8] = &[12, 86, 102, 116, 28, 77, 105, 110, 116, 101, 114, 115];
            type Params = ();
            type Reply = Vec<ActorId>;
        }
        pub struct Allowance(());
        impl Allowance {
            #[allow(dead_code)]
            pub fn encode_call(owner: ActorId, spender: ActorId) -> Vec<u8> {
                <Allowance as ActionIo>::encode_call(&(owner, spender))
            }
        }
        impl ActionIo for Allowance {
            const ROUTE: &'static [u8] = &[
                12, 86, 102, 116, 36, 65, 108, 108, 111, 119, 97, 110, 99, 101,
            ];
            type Params = (ActorId, ActorId);
            type Reply = U256;
        }
        pub struct BalanceOf(());
        impl BalanceOf {
            #[allow(dead_code)]
            pub fn encode_call(account: ActorId) -> Vec<u8> {
                <BalanceOf as ActionIo>::encode_call(&account)
            }
        }
        impl ActionIo for BalanceOf {
            const ROUTE: &'static [u8] =
                &[12, 86, 102, 116, 36, 66, 97, 108, 97, 110, 99, 101, 79, 102];
            type Params = ActorId;
            type Reply = U256;
        }
        pub struct Decimals(());
        impl Decimals {
            #[allow(dead_code)]
            pub fn encode_call() -> Vec<u8> {
                <Decimals as ActionIo>::encode_call(&())
            }
        }
        impl ActionIo for Decimals {
            const ROUTE: &'static [u8] =
                &[12, 86, 102, 116, 32, 68, 101, 99, 105, 109, 97, 108, 115];
            type Params = ();
            type Reply = u8;
        }
        pub struct Name(());
        impl Name {
            #[allow(dead_code)]
            pub fn encode_call() -> Vec<u8> {
                <Name as ActionIo>::encode_call(&())
            }
        }
        impl ActionIo for Name {
            const ROUTE: &'static [u8] = &[12, 86, 102, 116, 16, 78, 97, 109, 101];
            type Params = ();
            type Reply = String;
        }
        pub struct Symbol(());
        impl Symbol {
            #[allow(dead_code)]
            pub fn encode_call() -> Vec<u8> {
                <Symbol as ActionIo>::encode_call(&())
            }
        }
        impl ActionIo for Symbol {
            const ROUTE: &'static [u8] = &[12, 86, 102, 116, 24, 83, 121, 109, 98, 111, 108];
            type Params = ();
            type Reply = String;
        }
        pub struct TotalSupply(());
        impl TotalSupply {
            #[allow(dead_code)]
            pub fn encode_call() -> Vec<u8> {
                <TotalSupply as ActionIo>::encode_call(&())
            }
        }
        impl ActionIo for TotalSupply {
            const ROUTE: &'static [u8] = &[
                12, 86, 102, 116, 44, 84, 111, 116, 97, 108, 83, 117, 112, 112, 108, 121,
            ];
            type Params = ();
            type Reply = U256;
        }
    }

    #[allow(dead_code)]
    #[cfg(not(target_arch = "wasm32"))]
    pub mod events {
        use super::*;
        use sails_rs::events::*;
        #[derive(PartialEq, Debug, Encode, Decode)]
        #[codec(crate = sails_rs::scale_codec)]
        pub enum VftEvents {
            Minted {
                to: ActorId,
                value: U256,
            },
            Burned {
                from: ActorId,
                value: U256,
            },
            Approval {
                owner: ActorId,
                spender: ActorId,
                value: U256,
            },
            Transfer {
                from: ActorId,
                to: ActorId,
                value: U256,
            },
        }
        impl EventIo for VftEvents {
            const ROUTE: &'static [u8] = &[12, 86, 102, 116];
            const EVENT_NAMES: &'static [&'static [u8]] = &[
                &[24, 77, 105, 110, 116, 101, 100],
                &[24, 66, 117, 114, 110, 101, 100],
                &[32, 65, 112, 112, 114, 111, 118, 97, 108],
                &[32, 84, 114, 97, 110, 115, 102, 101, 114],
            ];
            type Event = Self;
        }
        pub fn listener<R: Listener<Vec<u8>>>(remoting: R) -> impl Listener<VftEvents> {
            RemotingListener::<_, VftEvents>::new(remoting)
        }
    }
}
/// Config that will be used to send messages to the other programs.
#[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo)]
#[codec(crate = sails_rs::scale_codec)]
#[scale_info(crate = sails_rs::scale_info)]
pub struct Config {
    /// Gas limit for token operations. Token operations include:
    /// - Mint
    /// - Burn
    /// - TransferFrom
    pub gas_for_token_ops: u64,
    /// Gas to reserve for reply processing.
    pub gas_for_reply_deposit: u64,
    /// Timeout in blocks that current program will wait for reply from
    /// the other programs such as VFT
    pub reply_timeout: u32,
    pub gas_for_full_tx: u64,
}
/// State in which message processing can be.
#[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo)]
#[codec(crate = sails_rs::scale_codec)]
#[scale_info(crate = sails_rs::scale_info)]
pub enum MessageStatus {
    SendingMsgToLockTokenA,
    /// Reply is received for a token deposit message.
    TokenALocked(bool),
    SendingMsgToLockTokenB,
    /// Reply is received for a token deposit message.
    TokenBLocked(bool),
    /// Message to refund tokens is sent.
    SendingMessageToReturnTokensA,
    /// Reply is received for a token refund message.
    TokensAReturnComplete(bool),
    SendingMsgToTransferTokenIn,
    TokenInTransfered(bool),
    SendingMsgToTransferTokenOut,
    TokenOutTransfered(bool),
    SendingMessageToReturnTokenIn,
    TokenInReturnComplete(bool),
    SendingMsgToUnlockTokenA,
    /// Reply is received for a token deposit message.
    TokenAUnlocked(bool),
    SendingTreasuryTokenA,
    SendingTreasuryTokenB,
    TreasuryTokenASent(bool),
    TreasuryTokenBSent(bool),
    SendingMsgToUnlockTokenB,
    /// Reply is received for a token deposit message.
    TokenBUnlocked(bool),
}

pub mod traits {
    use super::*;
    #[allow(dead_code)]
    pub trait PairClientFactory {
        type Args;
        #[allow(clippy::new_ret_no_self)]
        #[allow(clippy::wrong_self_convention)]
        fn new(
            &self,
            config: Config,
            token0: ActorId,
            token1: ActorId,
            fee_to: ActorId,
            treasury_id: ActorId,
            admin_id: ActorId,
        ) -> impl Activation<Args = Self::Args>;
    }

    #[allow(clippy::type_complexity)]
    pub trait Pair {
        type Args;
        fn add_liquidity(
            &mut self,
            amount_a_desired: U256,
            amount_b_desired: U256,
            amount_a_min: U256,
            amount_b_min: U256,
            deadline: u64,
        ) -> impl Call<Output = (), Args = Self::Args>;
        fn change_fee_to(
            &mut self,
            new_fee_to: ActorId,
        ) -> impl Call<Output = (), Args = Self::Args>;
        fn change_treasury_id(
            &mut self,
            new_treasury_id: ActorId,
        ) -> impl Call<Output = (), Args = Self::Args>;
        fn migrate_all_liquidity(
            &mut self,
            target: ActorId,
        ) -> impl Call<Output = (), Args = Self::Args>;
        fn remove_liquidity(
            &mut self,
            liquidity: U256,
            amount_a_min: U256,
            amount_b_min: U256,
            deadline: u64,
        ) -> impl Call<Output = (), Args = Self::Args>;
        fn send_treasury_fees(&mut self) -> impl Call<Output = (), Args = Self::Args>;
        fn set_lock(&mut self, lock: bool) -> impl Call<Output = (), Args = Self::Args>;
        fn swap_exact_tokens_for_tokens(
            &mut self,
            amount_in: U256,
            amount_out_min: U256,
            is_token0_to_token1: bool,
            deadline: u64,
        ) -> impl Call<Output = (), Args = Self::Args>;
        fn swap_tokens_for_exact_tokens(
            &mut self,
            amount_out: U256,
            amount_in_max: U256,
            is_token0_to_token1: bool,
            deadline: u64,
        ) -> impl Call<Output = (), Args = Self::Args>;
        fn calculate_lp_user_fee(
            &self,
            user: ActorId,
        ) -> impl Query<Output = U256, Args = Self::Args>;
        fn calculate_protocol_fee(&self) -> impl Query<Output = U256, Args = Self::Args>;
        fn calculate_remove_liquidity(
            &self,
            liquidity: U256,
        ) -> impl Query<Output = (U256, U256), Args = Self::Args>;
        fn get_amount_in(
            &self,
            amount_out: U256,
            is_token0_to_token1: bool,
        ) -> impl Query<Output = U256, Args = Self::Args>;
        fn get_amount_out(
            &self,
            amount_in: U256,
            is_token0_to_token1: bool,
        ) -> impl Query<Output = U256, Args = Self::Args>;
        fn get_reserves(&self) -> impl Query<Output = (U256, U256), Args = Self::Args>;
        fn get_tokens(&self) -> impl Query<Output = (ActorId, ActorId), Args = Self::Args>;
        fn get_treasury_info(
            &self,
        ) -> impl Query<Output = (ActorId, U256, U256), Args = Self::Args>;
        fn lock(&self) -> impl Query<Output = bool, Args = Self::Args>;
        fn migrated(&self) -> impl Query<Output = bool, Args = Self::Args>;
        fn msgs_in_msg_tracker(
            &self,
        ) -> impl Query<Output = Vec<(MessageId, MessageStatus)>, Args = Self::Args>;
        fn treasury_id(&self) -> impl Query<Output = ActorId, Args = Self::Args>;
    }

    #[allow(clippy::type_complexity)]
    pub trait Vft {
        type Args;
        fn grant_admin_role(&mut self, to: ActorId) -> impl Call<Output = (), Args = Self::Args>;
        fn grant_burner_role(&mut self, to: ActorId) -> impl Call<Output = (), Args = Self::Args>;
        fn grant_minter_role(&mut self, to: ActorId) -> impl Call<Output = (), Args = Self::Args>;
        fn revoke_admin_role(&mut self, from: ActorId)
        -> impl Call<Output = (), Args = Self::Args>;
        fn revoke_burner_role(
            &mut self,
            from: ActorId,
        ) -> impl Call<Output = (), Args = Self::Args>;
        fn revoke_minter_role(
            &mut self,
            from: ActorId,
        ) -> impl Call<Output = (), Args = Self::Args>;
        fn approve(
            &mut self,
            spender: ActorId,
            value: U256,
        ) -> impl Call<Output = bool, Args = Self::Args>;
        fn transfer(
            &mut self,
            to: ActorId,
            value: U256,
        ) -> impl Call<Output = bool, Args = Self::Args>;
        fn transfer_from(
            &mut self,
            from: ActorId,
            to: ActorId,
            value: U256,
        ) -> impl Call<Output = bool, Args = Self::Args>;
        fn admins(&self) -> impl Query<Output = Vec<ActorId>, Args = Self::Args>;
        fn burners(&self) -> impl Query<Output = Vec<ActorId>, Args = Self::Args>;
        fn minters(&self) -> impl Query<Output = Vec<ActorId>, Args = Self::Args>;
        fn allowance(
            &self,
            owner: ActorId,
            spender: ActorId,
        ) -> impl Query<Output = U256, Args = Self::Args>;
        fn balance_of(&self, account: ActorId) -> impl Query<Output = U256, Args = Self::Args>;
        fn decimals(&self) -> impl Query<Output = u8, Args = Self::Args>;
        fn name(&self) -> impl Query<Output = String, Args = Self::Args>;
        fn symbol(&self) -> impl Query<Output = String, Args = Self::Args>;
        fn total_supply(&self) -> impl Query<Output = U256, Args = Self::Args>;
    }
}
